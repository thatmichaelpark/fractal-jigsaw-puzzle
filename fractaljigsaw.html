<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<title>Fractal Jigsaw Puzzle</title>
	<style>

#drawdiv {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
}

	</style>
</head>
<body>
	<div id="drawdiv"">
		<canvas id="canvas">
		</canvas>
	</div>
	<script src="piece.js"></script>
	<script>
"use strict"

var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');
window.addEventListener('resize', resizeListener);
resize();

var worker = new Worker('worker.js');

var piecesToDraw = [];
var backgroundPiece = null;

var initialPath = [24, 24, 23, 25];
var maxPathLength = 4;
var topLevelData;

var storedData = localStorage.fractalJigsawPuzzleData001;

if (storedData && confirm('Continue from last time?')) {
	storedData = JSON.parse(storedData);
	initialPath = storedData.path;
	topLevelData = storedData.topLevelData;
} else {
	topLevelData = createTopLevelData(-0.7436424892193446, 0.1318316205585883, 5000000);
}

window.addEventListener("unload", function (e) {
	localStorage.fractalJigsawPuzzleData001 = JSON.stringify({
		path: currentLevel.path,
		topLevelData: topLevelData
	});
}, false);

var currentLevel = levelPath(initialPath);
initLevel();

var clickSound = new Audio('sounds/178186__snapper4298__camera-click-nikon.wav');
var zoomOutSound = new Audio('sounds/333078__michael-kur95__time-s-up.wav');
var zoomInSound = new Audio('sounds/333078__michael-kur95__time-s-up_reversed.wav');

var draggingPiece = null;
var selectedPiece = null;
var mouseOffsetX, mouseOffsetY;

function mousedownHandler(e) {
	var mouseX = e.clientX - canvas.width/2;
	var mouseY = e.clientY - canvas.height/2;
	for (var i=piecesToDraw.length; --i>=0;) {
		var ht = piecesToDraw[i].hitTest(mouseX, mouseY);
		if (ht) {
			mouseOffsetX = ht.x;
			mouseOffsetY = ht.y;
			if (selectedPiece == piecesToDraw[i]) {		// double-click
				if (selectedPiece.levelData.children) {	// not lowest level?
					zoomIn(selectedPiece.levelData.path);
					break;
				}
			}
			selectedPiece = piecesToDraw[i];
			setTimeout(function () { selectedPiece = null; }, 300);
/*			
			if (e.ctrlKey) {
				piecesToDraw[i].levelData.cx = piecesToDraw[i].levelData.fx;
				piecesToDraw[i].levelData.cy = piecesToDraw[i].levelData.fy;
				piecesToDraw[i].levelData.inPlace = true;
				var temp = piecesToDraw[i];
				piecesToDraw.splice(i, 1);			// move piece
				piecesToDraw.unshift(temp);			//  to bottom
				if (checkLevelDone()) {
					zoomOut();
				}
			} else {*/
				if (!piecesToDraw[i].levelData.inPlace) {
					draggingPiece = piecesToDraw[i];
					piecesToDraw.splice(i, 1);			// move touched piece
					piecesToDraw.push(draggingPiece);	//  to top
					draggingPiece.levelData.inPlace = false;
					draggingPiece.levelData.cx = mouseX + mouseOffsetX;
					draggingPiece.levelData.cy = mouseY + mouseOffsetY;
				}
//			}
			e.preventDefault();
			break;
		}
	}
	redraw();
}

function mousemoveHandler(e) {
	if (draggingPiece != null) {
		var mouseX = e.clientX - canvas.width/2 + mouseOffsetX;
		var mouseY = e.clientY - canvas.height/2 + mouseOffsetY;
		draggingPiece.levelData.cx = mouseX;
		draggingPiece.levelData.cy = mouseY;
		redraw();
		e.preventDefault();
	}
}

function mouseupHandler(e) {
	if (draggingPiece != null) {
		var mouseX = e.clientX - canvas.width/2 + mouseOffsetX;
		var mouseY = e.clientY - canvas.height/2 + mouseOffsetY;
		draggingPiece.levelData.cx = mouseX;
		draggingPiece.levelData.cy = mouseY;
		if (Math.abs(draggingPiece.levelData.fx - mouseX) < 13 &&
			Math.abs(draggingPiece.levelData.fy - mouseY) < 13 &&
			draggingPiece.levelData.isComplete) {
				draggingPiece.levelData.cx = draggingPiece.levelData.fx;
				draggingPiece.levelData.cy = draggingPiece.levelData.fy;
				piecesToDraw.pop();							// move piece
				piecesToDraw.unshift(draggingPiece);		//  to bottom
				draggingPiece.levelData.inPlace = true;
				clickSound.play();
		}
		redraw();
		draggingPiece = null;
		e.preventDefault();
		if (checkLevelDone()) {
			if (currentLevel == topLevelData) {
				alert('Puzzle solved!\nPlease send screenshot to\nthatmichaelpark@gmail.com');
			}
			zoomOut();
		}
	}
}

function enableMouse() {
	canvas.addEventListener('mousedown', mousedownHandler, false); 
	canvas.addEventListener('mousemove', mousemoveHandler, false); 
	canvas.addEventListener('mouseup', mouseupHandler, false); 
	window.addEventListener("keydown", keydownHandler, false);
//	window.addEventListener("keypress", keypressHandler, false);
}

enableMouse();

function disableMouse() {
	canvas.removeEventListener('mousedown', mousedownHandler); 
	canvas.removeEventListener('mousemove', mousemoveHandler); 
	canvas.removeEventListener('mouseup', mouseupHandler); 
	window.removeEventListener("keydown", keydownHandler);
//	window.removeEventListener("keypress", keypressHandler);
}

function keydownHandler(e) {
	if (e.keyCode == 27) {	// escape?
		if (checkLevelDone()) {
			zoomOut();
			redraw();
		}
	}
}

function keypressHandler(e) {
	if (e.charCode == 115) {	// 's'
		for (var i=0; i<piecesToDraw.length; ++i) {
			piecesToDraw[i].levelData.cx = piecesToDraw[i].levelData.fx;
			piecesToDraw[i].levelData.cy = piecesToDraw[i].levelData.fy;
			piecesToDraw[i].levelData.inPlace = true;
			piecesToDraw[i].levelData.isComplete = true;
		}
		redraw();
	} else if (e.charCode == 63) {	// '?'
		console.log(JSON.stringify(topLevelData).length);
	}
}

function checkLevelDone() {
	for (var i=1; i<piecesToDraw.length; ++i) {
		if (!piecesToDraw[i].levelData.inPlace) {
			return false;
		}
	}
	return true;
}

function levelPath(path) {
	var level = topLevelData;
	for (var i=0; i<path.length; ++i) {
		if (level.children.length == 0) {
			createChildren(level);
		}
		level = level.children[path[i]];
	}
	return level;
}

function initLevel(priorityLevel) {
// for currentLevel, create Piece objects for backgroundPiece and piecesToDraw.
// priorityLevel is moved to the front of the worker render queue.

	for (var i=0; i<piecesToDraw.length; ++i) {	// preserve drawing order
		piecesToDraw[i].levelData.zOrder = i;	//  of old current level
	}

	if (currentLevel.children.length == 0) {
		createChildren(currentLevel);
	}

	var children = currentLevel.children;
	var bigPiece = new Piece(4);
	bigPiece.xorRect(0, 0, bigPiece.wholeSide, bigPiece.wholeSide, 255, 255, 200, 0);
	if (currentLevel.isTop) {
		bigPiece.makeTopPiece(currentLevel.u0, currentLevel.v0, currentLevel.du, currentLevel.dv);
	} else {
		bigPiece.makePiece(currentLevel.u0, currentLevel.v0, currentLevel.du, currentLevel.dv);
	}
	bigPiece.outline();
	bigPiece.toImg();
	bigPiece.levelData = {cx: 0, cy: 0};
	backgroundPiece = bigPiece;
	piecesToDraw = [];

	for (var i=0; i<children.length; ++i) {
		var c = children[i];
		if (c == null) {
			continue;
		}
		var piece = new Piece(3);
		piece.levelData = c;
		var color = c.isComplete ? 100 : 210;
		piece.xorRect(0, 0, piece.wholeSide, piece.wholeSide, 255, color, color, 0);
		piece.makePiece(c.u0, c.v0, c.du, c.dv);
		piece.inoutline();
		piece.toImg();
		piecesToDraw.push(piece);
	}
	piecesToDraw.sort(function (a, b) { return a.levelData.zOrder - b.levelData.zOrder; });
	redraw();
	
	var piecesForWorker = [];
	for (var i=0; i<piecesToDraw.length; ++i) {
		piecesToDraw[i].rendered = false;
		if (piecesToDraw[i].levelData.isComplete) {
			piecesToDraw[i].randomizer = Math.random();
			if (piecesToDraw[i].levelData == priorityLevel) {
				piecesToDraw[i].randomizer = -1;
			}
			piecesForWorker.push(piecesToDraw[i]);
		}
	}
	piecesForWorker.sort(function (a, b) { return a.randomizer - b.randomizer; });

	var iout = 0;
	if (iout < piecesForWorker.length) {
		piece = piecesForWorker[iout];
		var ld = piece.levelData;
		var re = ld.re0 - ld.dre / piece.pieceSide * piece.padding;
		var im = ld.im0 - ld.dim / piece.pieceSide * piece.padding;
		var dre = ld.dre / piece.pieceSide * piece.wholeSide;
		var dim = ld.dim / piece.pieceSide * piece.wholeSide;
		worker.postMessage({path: ld.path, re: re, im: im, dre: dre, dim: dim, w: piece.wholeSide, h: piece.wholeSide, data: piece.imageData.data});
	}

	var iin = 0;
	worker.onmessage = function (event) {
		if (iin < piecesForWorker.length) {	// just in case level changed in the middle
			if (piecesForWorker[iin].levelData == levelPath(event.data.path)) {
				piecesForWorker[iin].imageData = new ImageData(event.data.data, piecesForWorker[iin].wholeSide, piecesForWorker[iin].wholeSide);
				piecesForWorker[iin].inoutline();
				piecesForWorker[iin].toImg();
				piecesForWorker[iin].rendered = true;
				++iin;
			}
		}
		++iout;
		if (iout < piecesForWorker.length) {
			piece = piecesForWorker[iout];
			var ld = piece.levelData;
			var re = ld.re0 - ld.dre / piece.pieceSide * piece.padding;
			var im = ld.im0 - ld.dim / piece.pieceSide * piece.padding;
			var dre = ld.dre / piece.pieceSide * piece.wholeSide;
			var dim = ld.dim / piece.pieceSide * piece.wholeSide;
			worker.postMessage({path: ld.path, re: re, im: im, dre: dre, dim: dim, w: piece.wholeSide, h: piece.wholeSide, data: piece.imageData.data});
		}
		redraw();
	};
}



function resize() {
	var div = document.getElementById('drawdiv');
	canvas.width = div.clientWidth;
	canvas.height = div.clientHeight;
	redraw();
}

var redrawing = false;
var redrawFunction = normalRedraw;

function redraw() {
	if (!redrawing) {
		redrawing = true;
		requestAnimationFrame(function (ms) {
			redrawing = false;
			redrawFunction(ms);
		});
	}
}

function normalRedraw(ms) {
	ctx.save();
	redrawBackground();
	redrawPieces();
	ctx.restore();
}

function redrawBackground() {
	ctx.fillStyle = 'teal';
	ctx.fillRect(0, 0, canvas.width, canvas.height);
	ctx.translate(canvas.width/2, canvas.height/2);
	if (backgroundPiece) {
		backgroundPiece.draw(ctx);
	}
}

function redrawPieces() {
	for (var i=0; i<piecesToDraw.length; ++i) {
		piecesToDraw[i].draw(ctx);
	}
}

function easeInOutQuad(t) {
	t *= 2;
	if (t < 1) return 0.5 * t * t;
	t--;
	return -0.5 * (t * (t-2) - 1);
}

var easingFunction = easeInOutQuad;

var zoomTime = 1500;
var fadeTime = 500;
var zoomInLevel;

function zoomIn(path) {
	zoomInLevel = levelPath(path);
	if (zoomInLevel.du > 1) {
		redrawFunction = zoomInLevel.isComplete ? zoomInRedrawComplete : zoomInRedrawBlank;
		zoomInSound.play();
	}
}

function zoomInRedrawBlank(ms) {
// zoom in on a not-completed piece
	var startTime = ms;
	var startX, startY;
	var ziScale, ziX, ziY;
	var alpha = 1;
	
	var ziPiecesToDraw = [backgroundPiece];
	for (var i=0; i<piecesToDraw.length; ++i) {
		ziPiecesToDraw.push(piecesToDraw[i]);
	}
	
	currentLevel = zoomInLevel;
	initLevel();
	var ziBackgroundPiece = backgroundPiece;
	
	ziX = startX = currentLevel.cx;
	ziY = startY = currentLevel.cy;
	ziScale = 0.2;
	redrawFunction = fadeOut;
	drawStuff();
	
	function fadeOut(ms) {
		var t = ms - startTime;
		alpha = 1 - t / fadeTime;
		if (t > fadeTime) {
			alpha = 0;
			startTime = ms;
			redrawFunction = zoomingIn;
		}
		drawStuff();
	}
	
	function zoomingIn(ms) {
		var t = ms - startTime;
		if (t > zoomTime) {
			t = zoomTime;
			ziPiecesToDraw = [backgroundPiece];
			for (var i=0; i<piecesToDraw.length; ++i) {
				ziPiecesToDraw.push(piecesToDraw[i]);
			}
			startTime = ms;
			redrawFunction = fadeIn;
		}
		var s = easingFunction(t/zoomTime);
		ziScale = 0.2 + s * 0.8;	// 0.2..1
		ziX = startX - s * startX;
		ziY = startY - s * startY;
		drawStuff();
	}
	
	function fadeIn(ms) {
		var t = ms - startTime;
		alpha = t / fadeTime;
		if (t > fadeTime) {
			alpha = 1;
			redrawFunction = normalRedraw;
		}
		drawStuff2();
	}
	
	function drawStuff() {
		ctx.save();
		ctx.fillStyle = 'teal';
		ctx.fillRect(0, 0, canvas.width, canvas.height);
		ctx.translate(canvas.width/2, canvas.height/2);
		ctx.save();
		ctx.globalAlpha = alpha;
		for (var i=0; i<ziPiecesToDraw.length; ++i) {
			ziPiecesToDraw[i].draw(ctx);
		}
		ctx.restore();
		ctx.translate(ziX, ziY);
		ctx.scale(ziScale, ziScale);
		ziBackgroundPiece.draw(ctx);
		ctx.restore();
		redraw();
	}
	
	function drawStuff2() {
		ctx.save();
		ctx.fillStyle = 'teal';
		ctx.fillRect(0, 0, canvas.width, canvas.height);
		ctx.translate(canvas.width/2, canvas.height/2);

		ctx.save();
		ctx.translate(ziX, ziY);
		ctx.scale(ziScale, ziScale);
		ziBackgroundPiece.draw(ctx);
		ctx.restore();

		ctx.globalAlpha = alpha;
		for (var i=0; i<ziPiecesToDraw.length; ++i) {
			ziPiecesToDraw[i].draw(ctx);
		}
		ctx.restore();
		redraw();
	}
}

function zoomInRedrawComplete(ms) {
// zoom in on a completed piece
	var startTime = ms;
	var ziPieceToDraw;
	var startX, startY;
	var ziScale, ziX, ziY;
	var alpha = 1;
	var zooming = true;
	
	for (var i=0; i<piecesToDraw.length; ++i) {	// find the piece being zoomed
	// Piece links to corresponding levelData, but not the other way around,
	// so, given zoomInLevel, we have to loop to find its Piece.
		if (zoomInLevel == piecesToDraw[i].levelData) {
			ziPieceToDraw = piecesToDraw[i];
			ziScale = 1;
			ziX = startX = piecesToDraw[i].levelData.cx;
			ziY = startY = piecesToDraw[i].levelData.cy;
			break;
		}
	}

	redrawFunction = fadeOut;
	drawStuff1();
	
	function fadeOut(ms) {
		var t = ms - startTime;
		alpha = 1 - t / fadeTime
		if (t > fadeTime) {
			alpha = 0;
			startTime = 0;
			piecesToDraw = [];
			backgroundPiece = null;
			currentLevel = zoomInLevel;
			initLevel();
			redrawFunction = zoomingIn;
		}
		drawStuff1();
	}
	
	function zoomingIn(ms) {
		if (!startTime) {
			startTime = ms;
		}
		var t = ms - startTime;
		if (t > zoomTime) {
			t = zoomTime;
			zooming = false;
			redrawFunction = waitTillAllRendered;
		}
		var s = easingFunction(t/zoomTime);
		ziScale = 1 + s * 4;		// 1..5
		ziX = startX - s * startX;
		ziY = startY - s * startY;
		drawStuff2();
	}

	var allRendered = false;
	
	function waitTillAllRendered(ms) {
		if (allRendered) {
			redrawFunction = normalRedraw;
		}
		drawStuff2();
	}
	
	function drawStuff1() {
		ctx.save();
		ctx.fillStyle = 'teal';
		ctx.fillRect(0, 0, canvas.width, canvas.height);
		ctx.translate(canvas.width/2, canvas.height/2);
		ctx.save();
		ctx.globalAlpha = alpha;
		backgroundPiece.draw(ctx);
		for (var i=0; i<piecesToDraw.length; ++i) {
			piecesToDraw[i].draw(ctx);
		}
		ctx.restore();
		ctx.translate(ziX-ziPieceToDraw.levelData.cx * ziScale,
						ziY-ziPieceToDraw.levelData.cy * ziScale);
		ctx.scale(ziScale, ziScale);
		ziPieceToDraw.draw(ctx);
		ctx.restore();
		redraw();
	}

	function drawStuff2() {
		ctx.save();
		ctx.fillStyle = 'teal';
		ctx.fillRect(0, 0, canvas.width, canvas.height);
		ctx.translate(canvas.width/2, canvas.height/2);
		ctx.save();
		ctx.translate(ziX-ziPieceToDraw.levelData.cx * ziScale,
						ziY-ziPieceToDraw.levelData.cy * ziScale);
		ctx.scale(ziScale, ziScale);
		ziPieceToDraw.draw(ctx);
		ctx.restore();
		allRendered = true;
		if (!zooming) {
			for (var i=0; i<piecesToDraw.length; ++i) {
				if (piecesToDraw[i].rendered) {
					piecesToDraw[i].draw(ctx);
				} else {
					allRendered = false;
				}
			}
		}
		ctx.restore();
		redraw();
	}
}

function zoomOut() {
	if (currentLevel.path.length > 0) {	// can't zoom out of top level
		if (currentLevel.isComplete = checkLevelDone()) {
			currentLevel.children = [];
			redrawFunction = zoomOutRedrawComplete;
		} else {
			redrawFunction = zoomOutRedrawBlank;
		}
		zoomOutSound.play();
	}
}

function zoomOutRedrawBlank(ms) {
// zoom out of a not-completed piece
	var startTime = ms;
	var zoPiecesToDraw = [];
	var zoScale, zoX, zoY;
	var alpha = 1;
	var bkgdAlpha = 1;
	var fadeTime = 500;
	
	var destX = currentLevel.cx;
	var destY = currentLevel.cy;

	var level = currentLevel;

	
	redrawFunction = fadeOut;
	drawStuff();
	
	function fadeOut(ms) {
		var t = ms - startTime;
		if (t > fadeTime) {
			t = fadeTime;
			startTime = ms;
			zoPiecesToDraw = [backgroundPiece];
			for (var i=0; i<piecesToDraw.length; ++i) {
				if (piecesToDraw[i].levelData.inPlace) {
					zoPiecesToDraw.push(piecesToDraw[i]);
				}
			}
			piecesToDraw = [];
			backgroundPiece = null;
			redrawFunction = zoomingOut;
		}
		alpha = 1 - t / fadeTime;
		drawStuff();
	}
	
	
	function zoomingOut(ms) {
		var t = ms - startTime;
		if (t > zoomTime) {
			t = zoomTime;
			redrawFunction = loadNextLevel;
		}
		var s = easingFunction(t/zoomTime);
		zoScale = 1 - s * 0.8;		// 1..0.2
		zoX = destX * s;
		zoY = destY * s;
		drawStuff();
	}
	
	function loadNextLevel(ms) {
		zoScale = 0.2;
		zoX = destX;
		zoY = destY;
		bkgdAlpha = 0;
		currentLevel = levelPath(currentLevel.path.slice(0, -1));
		initLevel(level);
		redrawFunction = fadeIn;
		startTime = 0;
		drawStuff();
	}
	
	function fadeIn(ms) {
		if (!startTime) {
			startTime = ms;
		}
		var t = ms - startTime;
		if (t > fadeTime) {
			t = fadeTime;
			zoPiecesToDraw = [];
			redrawFunction = normalRedraw;
		}
		bkgdAlpha = alpha = t/fadeTime;
		drawStuff();
	}
	
	function drawStuff() {
		ctx.save();
		ctx.fillStyle = 'teal';
		ctx.fillRect(0, 0, canvas.width, canvas.height);
		ctx.translate(canvas.width/2, canvas.height/2);
		if (backgroundPiece) {
			ctx.globalAlpha = bkgdAlpha;
			backgroundPiece.draw(ctx);
		}

		ctx.save();
		ctx.translate(zoX, zoY);
		ctx.scale(zoScale, zoScale);
		ctx.globalAlpha = 1;
		for (var i=0; i<zoPiecesToDraw.length; ++i) {
			zoPiecesToDraw[i].draw(ctx);
		}
		ctx.restore();
		
		ctx.globalAlpha = alpha;
		redrawPieces();	

		ctx.restore();
		redraw();
	}
}

function zoomOutRedrawComplete(ms) {
// zoom out of a completed piece
	disableMouse();
	
	var startTime = ms;
	var zoPiecesToDraw = [];
	var zoScale, zoX, zoY;
	var alpha = 0;
	
	var destX = currentLevel.cx;
	var destY = currentLevel.cy;

	var level = currentLevel;
	zoPiecesToDraw = piecesToDraw;
	piecesToDraw = [];
	backgroundPiece = null;
	
	redrawFunction = zoomingOut;
	drawStuff();
	
	function zoomingOut(ms) {
		var t = ms - startTime;
		if (t > zoomTime) {
			t = zoomTime;
			redrawFunction = loadNextLevel;
		}
		var s = easingFunction(t/zoomTime);
		zoScale = 1 - s * 0.8;		// 1..0.2
		zoX = destX * s;
		zoY = destY * s;
		drawStuff();
	}
	
	function loadNextLevel(ms) {
		zoScale = 0.2;
		zoX = destX;
		zoY = destY;
		currentLevel = levelPath(currentLevel.path.slice(0, -1));
		initLevel(level);
		redrawFunction = fadeIn;
		startTime = 0;
		drawStuff();
	}
	
	function fadeIn(ms) {
		if (!startTime) {
			startTime = ms;
		}
		var t = ms - startTime;
		if (t > fadeTime) {
			t = fadeTime;
			for (var i=0; i<piecesToDraw.length; ++i) {
				if (piecesToDraw[i].levelData == level && piecesToDraw[i].rendered) {
					zoPiecesToDraw = [];
					redrawFunction = normalRedraw;
					enableMouse();
				}
			}
		}
		alpha = t/fadeTime;
		drawStuff();
	}
	
	function drawStuff() {
		ctx.save();
		ctx.fillStyle = 'teal';
		ctx.fillRect(0, 0, canvas.width, canvas.height);
		ctx.translate(canvas.width/2, canvas.height/2);
		if (backgroundPiece) {
			backgroundPiece.draw(ctx);
		}

		ctx.globalAlpha = alpha;
		redrawPieces();	
	
		ctx.translate(zoX, zoY);
		ctx.scale(zoScale, zoScale);
		ctx.globalAlpha = 1;
		for (var i=0; i<zoPiecesToDraw.length; ++i) {
			zoPiecesToDraw[i].draw(ctx);
		}

		ctx.restore();
		redraw();
	}
}

function resizeListener(e) {
	resize();
}

function createTopLevelData(re, im, zoom, levels) {
	var re0 = re - 2/zoom;
	var im0 = im + 2/zoom;
	var dre = 4 / zoom;
	var dim = -4 / zoom;
	return createLevelData([], re0, im0, dre, dim, 100, 230, 3125, 3125, 0, 0, 0, 0, 0, false, false, true);
}

function createLevelData(path, re0, im0, dre, dim, u0, v0, du, dv, cx, cy, fx, fy, rot, inPlace, isComplete, isTop) {
	var levelData = {
		path: path.slice(),	// *copy* of path
		re0: re0,
		im0: im0,
		dre: dre,
		dim: dim,
		u0: u0,
		v0: v0,
		du: du,
		dv: dv,
		cx: cx,		// current position
		cy: cy,
		fx: fx,		// final position
		fy: fy,
		rot: rot,
		zOrder: 0,
		inPlace: inPlace,
		isComplete: isComplete,
		isTop: isTop,
		children: []
	};
	return levelData;
}

function createChildren(levelData) {
	var isComplete = levelData.isComplete;
	if (levelData.path.length == maxPathLength) {
		isComplete = true;
	}
	var inPlace = false;
	
	var piece = new Piece(1);
	piece.makePiece(levelData.u0, levelData.v0, levelData.du, levelData.dv);

	var dre = levelData.dre / 5;
	var dim = levelData.dim / 5;
	var du = levelData.du / 5;
	var dv = levelData.dv / 5;
	for (var i=-1; i<=5; ++i) {
		var v = levelData.v0 + i * dv;
		var im = levelData.im0 + i * dim;
		var fy = (i - 2) * 125;
		for (var j=-1; j<=5; ++j) {
			var u = levelData.u0 + j * du;
			var re = levelData.re0 + j * dre;
			var fx = (j - 2) * 125;
			var cx, cy;
			if (levelData.isComplete) {
				cx = fx;
				cy = fy;
				inPlace = true;
			} else {
				cx = (Math.random() - 0.5) * 7 * 125;
				cy = (Math.random() - 0.5) * 7 * 125;
			}
			if (piece.get(piece.padding+j, piece.padding+i).a || levelData.isTop) {
				levelData.path.push(levelData.children.length);
				levelData.children.push(createLevelData(levelData.path, re, im, dre, dim, u, v, du, dv, cx, cy, fx, fy, levelData.rot, inPlace, isComplete, false));
				levelData.path.pop();
			} else {
				levelData.children.push(null);
			}
		}
	}
}
	</script>
</body>
</html>
